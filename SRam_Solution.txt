------  Problem 1: Data Loading  ------
Sentencia para copiar el archivo al namenode local system files:    
    gcloud compute scp ./car_insurance_cold_calls_dataset.csv sebastian_r_07_12_02@gds-cluster-m:

Creamos el directorio en hdfs para esta asignación:
    hdfs dfs -mkdir /user/hive/hive_ass1

Colocamos el archivo al directorio creado:
    hdfs dfs -put car_insurance_cold_calls_dataset.csv /user/hive/hive_ass1

-Dentro de la consola de Hive-
    Creamos la Base de Datos:
        create database hive_db;
    
    Usamos la Base de Datos:
        use hive_db;

    Creamos la tabla externa solicitada:
CREATE EXTERNAL TABLE car_insurance_cold_calls_dataset 
(
    Id               INT,
    Age              INT,
    Job              STRING,
    Marital          STRING,
    Education        STRING,
    Default          INT,
    Balance          INT,
    HHInsurance      INT,
    CarLoan          INT,
    Communication    STRING,
    LastContactDay   INT,
    LastContactMonth STRING,
    NoOfContacts     INT,
    DaysPassed       INT,
    PrevAttempts     INT,
    Outcome          STRING,
    CallStart        STRING,
    CallEnd          STRING,
    CarInsurance     INT
)
row format serde 'org.apache.hadoop.hive.serde2.OpenCSVSerde'
with serdeproperties (
  'separatorChar' = ',',
  'quoteChar' = '\"',
  'escapeChar' = '\\'
)
stored as textfile
TBLPROPERTIES (
  "skip.header.line.count"="1",
  "serialization.null.format"="",
  "line.delim"="\r\n"
); 

    Aqui pues como uso Windows, al momento de insertar la idea es que 
    escape las filas correctamente pero no se ha podido, por el contrario
    se han registrado todas las filas pero entre cada fila del archivo real
    pues Hive agregó una fila con puros valores nulos. 
    Para esta asignación lo dejaré así pues es como que el tamaño de la tabla
    lo duplica y me sirve para las consultas, ya que mientras más grande
    sea el archivo, mejor podremos ver el poder de Hive.  

    Cargamos el archivo dentro de la tabla creada:
        load data inpath '/user/hive/hive_ass1/' into table car_insurance_cold_calls_dataset;

------  Problem 2: Data Exploration  ------
1. How many records are there in the dataset?
    select count(*) as yr 
    from car_insurance_cold_calls_dataset;

2. How many unique job categories are there?
    select distinct Job as yr 
    from car_insurance_cold_calls_dataset;

3. What is the age distribution of customers in the dataset? 
Provide a breakdown by age group: 18-30, 31-45, 46-60, 61+
    with AgeGroups as 
    (select         
        CASE
            WHEN Age BETWEEN 18 AND 30 THEN '18-30'
            WHEN Age BETWEEN 31 AND 45 THEN '31-45'
            WHEN Age BETWEEN 46 AND 60 THEN '46-60'
            WHEN Age >= 61 THEN '61+'
        END AS AgeGroup
    from car_insurance_cold_calls_dataset)

    select     
        AgeGroup,
        COUNT(*) AS TotalCustomers
    from AgeGroups
    group by AgeGroup
    order by AgeGroup;

4. Count the number of records that have missing values in any
field.
    select count(*) as MissingValueRecords
    from car_insurance_cold_calls_dataset
    where Id IS NULL OR Id = 'NA'
        OR Age IS NULL OR Age = 'NA'
        OR Job IS NULL OR Job = 'NA'
        OR Marital IS NULL OR Marital = 'NA'
        OR Education IS NULL OR Education = 'NA'
        OR Default IS NULL OR Default = 'NA'
        OR Balance IS NULL OR Balance = 'NA'
        OR HHInsurance IS NULL OR HHInsurance = 'NA'
        OR CarLoan IS NULL OR CarLoan = 'NA'
        OR Communication IS NULL OR Communication = 'NA'
        OR LastContactDay IS NULL OR LastContactDay = 'NA'
        OR LastContactMonth IS NULL OR LastContactMonth = 'NA'
        OR NoOfContacts IS NULL OR NoOfContacts = 'NA'
        OR DaysPassed IS NULL OR DaysPassed = 'NA'
        OR PrevAttempts IS NULL OR PrevAttempts = 'NA'
        OR Outcome IS NULL OR Outcome = 'NA'
        OR CallStart IS NULL OR CallStart = 'NA'
        OR CallEnd IS NULL OR CallEnd = 'NA'
        OR CarInsurance IS NULL OR CarInsurance = 'NA';

5. Determine the number of unique 'Outcome' values and their
respective counts.
    select Outcome, count(*) as c
    from car_insurance_cold_calls_dataset
    group by Outcome;

6. Find the number of customers who have both a car loan and
home insurance.
    select count(*) as c
    from car_insurance_cold_calls_dataset
    where CarLoan = 1 and HHInsurance = 1; 

------  Problem 3: Aggregations  ------
1. What is the average, minimum, and maximum balance for each
job category?
    select Job, avg(Balance) as avg, min(Balance) as min, max(Balance) as max
    from car_insurance_cold_calls_dataset
    group by Job; 

2. Find the total number of customers with and without car
insurance.
    select CarInsurance, count(*) as r
    from car_insurance_cold_calls_dataset
    where CarInsurance = 1

    union all 

    select CarInsurance, count(*) as r
    from car_insurance_cold_calls_dataset
    where CarInsurance = 0;

3. Count the number of customers for each communication type.
    select Communication, count(*) as r
    from car_insurance_cold_calls_dataset
    group by Communication; 

4. Calculate the sum of 'Balance' for each 'Communication' type.
    select Communication, sum(Balance) as r
    from car_insurance_cold_calls_dataset
    group by Communication; 

5. Count the number of 'PrevAttempts' for each 'Outcome' type.
    select Outcome, sum(PrevAttempts) as r
    from car_insurance_cold_calls_dataset
    group by Outcome; 

6. Calculate the average 'NoOfContacts' for people with and without
'CarInsurance'.
    select CarInsurance, avg(NoOfContacts) as r
    from car_insurance_cold_calls_dataset
    where CarInsurance = 1

    union all 

    select CarInsurance, avg(NoOfContacts) as r
    from car_insurance_cold_calls_dataset
    where CarInsurance = 0;

------  Problem 4: Partitioning and Bucketing  ------

1. Create a partitioned table on 'Education' and 'Marital' status. Load
data from the original table to this new partitioned table.
    CREATE TABLE car_insurance_cold_calls_dataset_partitioned_v1
    (
        Id               INT,
        Age              INT,
        Job              STRING,
        Default          INT,
        Balance          INT,
        HHInsurance      INT,
        CarLoan          INT,
        Communication    STRING,
        LastContactDay   INT,
        LastContactMonth STRING,
        NoOfContacts     INT,
        DaysPassed       INT,
        PrevAttempts     INT,
        Outcome          STRING,
        CallStart        STRING,
        CallEnd          STRING,
        CarInsurance     INT
    ) 
    PARTITIONED BY (Education STRING, Marital STRING)
    STORED AS PARQUET;

    SET hive.exec.dynamic.partition = true;
    SET hive.exec.dynamic.partition.mode = nonstrict;

    INSERT OVERWRITE TABLE car_insurance_cold_calls_dataset_partitioned_v1
    PARTITION (Education, Marital)
    SELECT
        Id,
        Age,
        Job,
        Default,
        Balance,
        HHInsurance,
        CarLoan,
        Communication,
        LastContactDay,
        LastContactMonth,
        NoOfContacts,
        DaysPassed,
        PrevAttempts,
        Outcome,
        CallStart,
        CallEnd,
        CarInsurance,
        Education,
        Marital
    FROM car_insurance_cold_calls_dataset
    WHERE Education IS NOT NULL and Education <> 'NA'
    AND   Marital IS NOT NULL and Marital <> 'NA';

2. Create a bucketed table on 'Age', bucketed into 4 groups (as per
the age groups mentioned above). Load data from the original
table into this bucketed table.
    CREATE TABLE car_insurance_cold_calls_dataset_bucketed_v1 
    (
        Id               INT,
        Age              INT,
        AgeGroup         STRING,
        Job              STRING,
        Marital          STRING,
        Education        STRING,
        Default          INT,
        Balance          INT,
        HHInsurance      INT,
        CarLoan          INT,
        Communication    STRING,
        LastContactDay   INT,
        LastContactMonth STRING,
        NoOfContacts     INT,
        DaysPassed       INT,
        PrevAttempts     INT,
        Outcome          STRING,
        CallStart        STRING,
        CallEnd          STRING,
        CarInsurance     INT
    )
    CLUSTERED BY (AgeGroup) INTO 4 BUCKETS
    STORED AS PARQUET;

    INSERT OVERWRITE TABLE car_insurance_cold_calls_dataset_bucketed_v1
    SELECT
        Id,
        Age,
        CASE 
            WHEN Age BETWEEN 18 AND 30 THEN '18-30'
            WHEN Age BETWEEN 31 AND 45 THEN '31-45'
            WHEN Age BETWEEN 46 AND 60 THEN '46-60'
            ELSE '61+'
        END AS AgeGroup,
        Job,
        Marital,
        Education,
        Default,
        Balance,
        HHInsurance,
        CarLoan,
        Communication,
        LastContactDay,
        LastContactMonth,
        NoOfContacts,
        DaysPassed,
        PrevAttempts,
        Outcome,
        CallStart,
        CallEnd,
        CarInsurance
    FROM car_insurance_cold_calls_dataset
    WHERE Age IS NOT NULL and Age <> 'NA';

3. Add an additional partition on 'Job' to the partitioned table created
earlier and move the data accordingly.
    CREATE TABLE car_insurance_cold_calls_dataset_partitioned_v2
    (
        Id               INT,
        Age              INT,
        Default          INT,
        Balance          INT,
        HHInsurance      INT,
        CarLoan          INT,
        Communication    STRING,
        LastContactDay   INT,
        LastContactMonth STRING,
        NoOfContacts     INT,
        DaysPassed       INT,
        PrevAttempts     INT,
        Outcome          STRING,
        CallStart        STRING,
        CallEnd          STRING,
        CarInsurance     INT
    ) 
    PARTITIONED BY (Job STRING, Education STRING, Marital STRING)
    STORED AS PARQUET;

    SET hive.exec.dynamic.partition = true;
    SET hive.exec.dynamic.partition.mode = nonstrict;

    INSERT OVERWRITE TABLE car_insurance_cold_calls_dataset_partitioned_v2
    PARTITION (Job, Education, Marital)
    SELECT
        Id,
        Age,
        Default,
        Balance,
        HHInsurance,
        CarLoan,
        Communication,
        LastContactDay,
        LastContactMonth,
        NoOfContacts,
        DaysPassed,
        PrevAttempts,
        Outcome,
        CallStart,
        CallEnd,
        CarInsurance,
        Job,
        Education,
        Marital
    FROM car_insurance_cold_calls_dataset
    WHERE Job IS NOT NULL AND Job <> 'NA'
    AND   Education IS NOT NULL and Education <> 'NA'
    AND   Marital IS NOT NULL and Marital <> 'NA';

4. Increase the number of buckets in the bucketed table to 10 and
redistribute the data.
    CREATE TABLE car_insurance_cold_calls_dataset_bucketed_v2        
    (
        Id               INT,
        Age              INT,
        AgeGroup         STRING,
        Job              STRING,
        Marital          STRING,
        Education        STRING,
        Default          INT,
        Balance          INT,
        HHInsurance      INT,
        CarLoan          INT,
        Communication    STRING,
        LastContactDay   INT,
        LastContactMonth STRING,
        NoOfContacts     INT,
        DaysPassed       INT,
        PrevAttempts     INT,
        Outcome          STRING,
        CallStart        STRING,
        CallEnd          STRING,
        CarInsurance     INT
    )
    CLUSTERED BY (AgeGroup) INTO 10 BUCKETS
    STORED AS PARQUET;

    SET hive.enforce.bucketing = true;
    SET mapreduce.job.reduces = 10;

    INSERT OVERWRITE TABLE car_insurance_cold_calls_dataset_bucketed_v2
    SELECT *
    FROM car_insurance_cold_calls_dataset_bucketed_v1;

------  Problem 5: Optimized Joins  ------
1. Join the original table with the partitioned table and find out the
average 'Balance' for each 'Job' and 'Education' level.
    SELECT t2.Job, t2.Education, avg(t2.Balance) as avg_bal
    FROM car_insurance_cold_calls_dataset t1 
    JOIN car_insurance_cold_calls_dataset_partitioned_v2 t2 
    ON t1.id = t2.id
    GROUP BY t2.Job, t2.Education;

2. Join the original table with the bucketed table and calculate the
total 'NoOfContacts' for each 'Age' group.
    SELECT t2.AgeGroup, sum(t2.NoOfContacts) as r
    FROM car_insurance_cold_calls_dataset t1 
    JOIN car_insurance_cold_calls_dataset_bucketed_v2 t2 
    ON t1.id = t2.id
    GROUP BY t2.AgeGroup;

3. Join the partitioned table and the bucketed table based on the 'Id'
field and find the total balance for each education level and
marital status for each age group.
    SELECT t2.AgeGroup, t1.Education, t1.Marital, sum(t1.Balance) as r
    FROM car_insurance_cold_calls_dataset_partitioned_v2 t1 
    JOIN car_insurance_cold_calls_dataset_bucketed_v2 t2 
    ON t1.id = t2.id
    GROUP BY 
        t2.AgeGroup,
        t1.Education,
        t1.Marital;

------  Problem 6: Window Function  ------
1. Calculate the acumulative sum of 'NoOfContacts' for each 'Job'
category, ordered by 'Age'.
    SELECT 
        Job, 
        Age, 
        SUM(NoOfContacts) 
            OVER(PARTITION BY Job 
                 ORDER BY Age 
                 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) 
        as r
    FROM car_insurance_cold_calls_dataset_partitioned_v2;

2. Calculate the running average of 'Balance' for each 'Job'
category, ordered by 'Age'.
    SELECT 
        Job,
        Age,
        Balance,
        AVG(Balance) OVER (
            PARTITION BY Job
            ORDER BY Age ASC
            ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
        ) AS r  
    FROM car_insurance_cold_calls_dataset_partitioned_v2;

3. For each 'Job' category, find the maximum 'Balance' for each
'Age' group using window functions.
    SELECT 
        Job,
        AgeGroup,
        MAX(Balance) OVER (PARTITION BY Job, AgeGroup) AS r
    FROM car_insurance_cold_calls_dataset_bucketed_v2;

4. Calculate the rank of 'Balance' within each 'Job' category, ordered
by 'Balance' descending.
    SELECT 
        Job, 
        Balance,
        DENSE_RANK() OVER (PARTITION BY Job ORDER BY Balance ASC) as r 
    FROM car_insurance_cold_calls_dataset_partitioned_v2;

------  Problem 7: Advanced Aggregations  ------
1. Find the job category with the highest number of car insurances.
    SELECT Job, COUNT(CarInsurance) as rp
    FROM car_insurance_cold_calls_dataset_partitioned_v2
    WHERE CarInsurance = 1
    GROUP BY Job
    ORDER BY COUNT(CarInsurance) DESC
    LIMIT 1;

2. Which month has seen the highest number of last contacts?
    SELECT LastContactMonth, SUM(NoOfContacts) as r
    FROM car_insurance_cold_calls_dataset_partitioned_v2
    WHERE LastContactMonth IS NOT NULL and LastContactMonth <> 'NA'
    GROUP BY LastContactMonth
    ORDER BY SUM(NoOfContacts) DESC
    LIMIT 1;

3. Calculate the ratio of the number of customers with car insurance
to the number of customers without car insurance for each job
category.
    WITH t1 as
    (SELECT Job, COUNT(id) as rp1
    FROM car_insurance_cold_calls_dataset_partitioned_v2
    WHERE CarInsurance = 1
    GROUP BY Job),
    t2 as
    (SELECT Job, COUNT(id) as rp2
    FROM car_insurance_cold_calls_dataset_partitioned_v2
    WHERE CarInsurance = 0
    GROUP BY Job)
    
    SELECT t1.Job, ROUND(t1.rp1 / t2.rp2, 2) AS r
    FROM t1
    JOIN t2 
    ON t1.Job = t2.Job;

4. Find out the 'Job' and 'Education' level combination which has the
highest number of car insurances.
    SELECT Job, Education, COUNT(id) as r
    FROM car_insurance_cold_calls_dataset_partitioned_v2
    WHERE CarInsurance = 1
    GROUP BY Job, Education
    ORDER BY COUNT(id) DESC
    LIMIT 1;

5. Calculate the average 'NoOfContacts' for each 'Outcome' and
'Job' combination.
    SELECT Outcome, Job, ROUND(AVG(NoOfContacts), 2) as r
    FROM car_insurance_cold_calls_dataset_partitioned_v2
    WHERE Outcome IS NOT NULL and Outcome <> 'NA'
    GROUP BY Outcome, Job;


6. Determine the month with the highest total 'Balance' of
customers.
    SELECT LastContactMonth, SUM(Balance) as r
    FROM car_insurance_cold_calls_dataset_partitioned_v2
    GROUP BY LastContactMonth
    ORDER BY SUM(Balance) DESC
    LIMIT 1;

------  Problem 8: Complex joins and aggregations  ------
1. For customers who have both a car loan and home insurance,
find out the average 'Balance' for each 'Education' level.
    SELECT Education, AVG(Balance) as r
    FROM car_insurance_cold_calls_dataset_partitioned_v1
    WHERE HHInsurance = 1
    AND   CarLoan = 1
    GROUP BY Education;

2. Identify the top 3 'Communication' types for customers with
'CarInsurance', and display their average 'NoOfContacts'.
    SELECT Communication, AVG(NoOfContacts) as r
    FROM car_insurance_cold_calls_dataset_partitioned_v1
    WHERE CarInsurance = 1
    AND   Communication IS NOT NULL and Communication <> 'NA'
    GROUP BY Communication
    ORDER BY r DESC
    LIMIT 3;

3. For customers who have a car loan, calculate the average
balance for each job category.
    SELECT Job, AVG(Balance) as r
    FROM car_insurance_cold_calls_dataset_partitioned_v2
    WHERE CarLoan = 1
    GROUP BY Job;

4. Identify the top 5 job categories that have the most customers
with a 'default', and show their average 'balance'.
    SELECT Job, AVG(Balance) as r
    FROM car_insurance_cold_calls_dataset_partitioned_v2
    WHERE default = 1
    GROUP BY Job
    ORDER BY r DESC
    LIMIT 5;

------  Problem 9: Advanced Window Functions  ------
1. Calculate the difference in 'NoOfContacts' between each
customer and the customer with the next highest number of
contacts in the same 'Job' category.
    WITH t1 as 
    (SELECT Job, 
            Id,
            NoOfContacts,
            LEAD(NoOfContacts, 1) 
                OVER(PARTITION BY Job ORDER BY NoOfContacts ASC) as r1
    FROM car_insurance_cold_calls_dataset_partitioned_v2)
    SELECT 
        Job,
        Id,
        r1,
        (r1 - NoOfContacts) AS R
    FROM t1;

2. For each customer, calculate the difference between their
'balance' and the average 'balance' of their 'job' category.
    WITH t1 as
    (SELECT Job, AVG(Balance) as r
    FROM car_insurance_cold_calls_dataset_partitioned_v2
    GROUP BY Job)
    SELECT 
        y1.Id, 
        y1.Job, 
        y1.Balance, 
        t1.r AS avg_balance_job, 
        ROUND(y1.Balance - t1.r, 2) as R
    FROM car_insurance_cold_calls_dataset_partitioned_v2 y1
    JOIN t1
    ON y1.Job = t1.Job;

3. For each 'Job' category, find the customer who had the longest
call duration.
    WITH t1 as 
    (SELECT Job, 
           Id, 
           unix_timestamp(CallEnd, 'HH:mm:ss') - unix_timestamp(CallStart, 'HH:mm:ss') AS r1
    FROM car_insurance_cold_calls_dataset_partitioned_v2
    WHERE CallEnd IS NOT NULL and CallEnd <> 'NA'
    AND   CallStart IS NOT NULL and CallStart <> 'NA'),
    t2 as
    (SELECT Job,
           Id, 
           RANK() OVER (PARTITION BY Job ORDER BY r1 DESC) AS r2
    FROM t1) 
    SELECT Job, Id
    FROM t2
    WHERE r2=1;

4. Calculate the moving average of 'NoOfContacts' within each 'Job'
category, using a window frame of the current row and the two
preceding rows.
    SELECT Job,
           Id,
           AVG(NoOfContacts) 
            OVER (PARTITION BY Job
                  ORDER BY Id 
                  ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as R
    FROM car_insurance_cold_calls_dataset_partitioned_v2;

------  Problem 10: Performance Tuning  ------
1. Experiment with different file formats (like ORC, Parquet) and
measure their impact on the performance of your Hive queries.

2. Use different levels of compression and observe their effects on
storage and query performance.

3. Compare the execution time of join queries with and without
bucketing.

4. Optimize your Hive queries using different Hive optimization
techniques (for example, predicate pushdown, map-side joins,
etc.). Discuss the difference in performance.